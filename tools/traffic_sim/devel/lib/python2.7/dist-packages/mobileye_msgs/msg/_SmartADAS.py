# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from mobileye_msgs/SmartADAS.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class SmartADAS(genpy.Message):
  _md5sum = "2234fe7679b621d841bd2d8b34cf58ad"
  _type = "mobileye_msgs/SmartADAS"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """uint8 persistent_on_off
uint8 volume_level
uint8 hmw_level
uint8 ldw_volume_level
uint8 hmw_volume_level
uint8 ldw_level
uint8 pedestrian_warning_level
uint8 sli_warning_level
uint8 blinker_reminder_level
uint8 virtual_bumper_level
uint8 hw_repeatable_level

uint8 buzzer_min_volume
uint8 buzzer_max_volume
uint8 buzzer_hmw_min_volume
uint8 buzzer_hmw_max_volume
uint8 buzzer_ldw_min_volume
uint8 buzzer_ldw_max_volume
uint8 ewiii_speed_indication
uint8 disable_system_off
uint8 calibration_source
uint8 ldw_min_value
uint8 ldw_max_value
uint8 ldw_speed
uint8 ped_min_value
uint8 ped_max_value
uint8 speed_for_high_low_beam_control
uint8 virtual_bumper_min_value
uint8 virtual_bumper_max_value
uint8 blinker_reminder_min_value
uint8 blinker_reminder_max_value

uint8 hmw_min_value
uint8 hmw_max_value
uint8 hmw_repeatable_min_value
uint8 hmw_repeatable_max_value
uint8 sli_min_value
uint8 sli_max_value
uint8 sli_delta_round_step
uint8 sli_delta_round_upwards
uint8 country_code
uint8 sli_unit_speed
uint8 tamper_alert_on_frames
uint8 tamper_alert_off_frames
uint8 tamper_alert_enable_j1939

bool[16] menu_ticks

bool[16] advanced_menu_ticks"""
  __slots__ = ['persistent_on_off','volume_level','hmw_level','ldw_volume_level','hmw_volume_level','ldw_level','pedestrian_warning_level','sli_warning_level','blinker_reminder_level','virtual_bumper_level','hw_repeatable_level','buzzer_min_volume','buzzer_max_volume','buzzer_hmw_min_volume','buzzer_hmw_max_volume','buzzer_ldw_min_volume','buzzer_ldw_max_volume','ewiii_speed_indication','disable_system_off','calibration_source','ldw_min_value','ldw_max_value','ldw_speed','ped_min_value','ped_max_value','speed_for_high_low_beam_control','virtual_bumper_min_value','virtual_bumper_max_value','blinker_reminder_min_value','blinker_reminder_max_value','hmw_min_value','hmw_max_value','hmw_repeatable_min_value','hmw_repeatable_max_value','sli_min_value','sli_max_value','sli_delta_round_step','sli_delta_round_upwards','country_code','sli_unit_speed','tamper_alert_on_frames','tamper_alert_off_frames','tamper_alert_enable_j1939','menu_ticks','advanced_menu_ticks']
  _slot_types = ['uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','bool[16]','bool[16]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       persistent_on_off,volume_level,hmw_level,ldw_volume_level,hmw_volume_level,ldw_level,pedestrian_warning_level,sli_warning_level,blinker_reminder_level,virtual_bumper_level,hw_repeatable_level,buzzer_min_volume,buzzer_max_volume,buzzer_hmw_min_volume,buzzer_hmw_max_volume,buzzer_ldw_min_volume,buzzer_ldw_max_volume,ewiii_speed_indication,disable_system_off,calibration_source,ldw_min_value,ldw_max_value,ldw_speed,ped_min_value,ped_max_value,speed_for_high_low_beam_control,virtual_bumper_min_value,virtual_bumper_max_value,blinker_reminder_min_value,blinker_reminder_max_value,hmw_min_value,hmw_max_value,hmw_repeatable_min_value,hmw_repeatable_max_value,sli_min_value,sli_max_value,sli_delta_round_step,sli_delta_round_upwards,country_code,sli_unit_speed,tamper_alert_on_frames,tamper_alert_off_frames,tamper_alert_enable_j1939,menu_ticks,advanced_menu_ticks

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(SmartADAS, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.persistent_on_off is None:
        self.persistent_on_off = 0
      if self.volume_level is None:
        self.volume_level = 0
      if self.hmw_level is None:
        self.hmw_level = 0
      if self.ldw_volume_level is None:
        self.ldw_volume_level = 0
      if self.hmw_volume_level is None:
        self.hmw_volume_level = 0
      if self.ldw_level is None:
        self.ldw_level = 0
      if self.pedestrian_warning_level is None:
        self.pedestrian_warning_level = 0
      if self.sli_warning_level is None:
        self.sli_warning_level = 0
      if self.blinker_reminder_level is None:
        self.blinker_reminder_level = 0
      if self.virtual_bumper_level is None:
        self.virtual_bumper_level = 0
      if self.hw_repeatable_level is None:
        self.hw_repeatable_level = 0
      if self.buzzer_min_volume is None:
        self.buzzer_min_volume = 0
      if self.buzzer_max_volume is None:
        self.buzzer_max_volume = 0
      if self.buzzer_hmw_min_volume is None:
        self.buzzer_hmw_min_volume = 0
      if self.buzzer_hmw_max_volume is None:
        self.buzzer_hmw_max_volume = 0
      if self.buzzer_ldw_min_volume is None:
        self.buzzer_ldw_min_volume = 0
      if self.buzzer_ldw_max_volume is None:
        self.buzzer_ldw_max_volume = 0
      if self.ewiii_speed_indication is None:
        self.ewiii_speed_indication = 0
      if self.disable_system_off is None:
        self.disable_system_off = 0
      if self.calibration_source is None:
        self.calibration_source = 0
      if self.ldw_min_value is None:
        self.ldw_min_value = 0
      if self.ldw_max_value is None:
        self.ldw_max_value = 0
      if self.ldw_speed is None:
        self.ldw_speed = 0
      if self.ped_min_value is None:
        self.ped_min_value = 0
      if self.ped_max_value is None:
        self.ped_max_value = 0
      if self.speed_for_high_low_beam_control is None:
        self.speed_for_high_low_beam_control = 0
      if self.virtual_bumper_min_value is None:
        self.virtual_bumper_min_value = 0
      if self.virtual_bumper_max_value is None:
        self.virtual_bumper_max_value = 0
      if self.blinker_reminder_min_value is None:
        self.blinker_reminder_min_value = 0
      if self.blinker_reminder_max_value is None:
        self.blinker_reminder_max_value = 0
      if self.hmw_min_value is None:
        self.hmw_min_value = 0
      if self.hmw_max_value is None:
        self.hmw_max_value = 0
      if self.hmw_repeatable_min_value is None:
        self.hmw_repeatable_min_value = 0
      if self.hmw_repeatable_max_value is None:
        self.hmw_repeatable_max_value = 0
      if self.sli_min_value is None:
        self.sli_min_value = 0
      if self.sli_max_value is None:
        self.sli_max_value = 0
      if self.sli_delta_round_step is None:
        self.sli_delta_round_step = 0
      if self.sli_delta_round_upwards is None:
        self.sli_delta_round_upwards = 0
      if self.country_code is None:
        self.country_code = 0
      if self.sli_unit_speed is None:
        self.sli_unit_speed = 0
      if self.tamper_alert_on_frames is None:
        self.tamper_alert_on_frames = 0
      if self.tamper_alert_off_frames is None:
        self.tamper_alert_off_frames = 0
      if self.tamper_alert_enable_j1939 is None:
        self.tamper_alert_enable_j1939 = 0
      if self.menu_ticks is None:
        self.menu_ticks = [False] * 16
      if self.advanced_menu_ticks is None:
        self.advanced_menu_ticks = [False] * 16
    else:
      self.persistent_on_off = 0
      self.volume_level = 0
      self.hmw_level = 0
      self.ldw_volume_level = 0
      self.hmw_volume_level = 0
      self.ldw_level = 0
      self.pedestrian_warning_level = 0
      self.sli_warning_level = 0
      self.blinker_reminder_level = 0
      self.virtual_bumper_level = 0
      self.hw_repeatable_level = 0
      self.buzzer_min_volume = 0
      self.buzzer_max_volume = 0
      self.buzzer_hmw_min_volume = 0
      self.buzzer_hmw_max_volume = 0
      self.buzzer_ldw_min_volume = 0
      self.buzzer_ldw_max_volume = 0
      self.ewiii_speed_indication = 0
      self.disable_system_off = 0
      self.calibration_source = 0
      self.ldw_min_value = 0
      self.ldw_max_value = 0
      self.ldw_speed = 0
      self.ped_min_value = 0
      self.ped_max_value = 0
      self.speed_for_high_low_beam_control = 0
      self.virtual_bumper_min_value = 0
      self.virtual_bumper_max_value = 0
      self.blinker_reminder_min_value = 0
      self.blinker_reminder_max_value = 0
      self.hmw_min_value = 0
      self.hmw_max_value = 0
      self.hmw_repeatable_min_value = 0
      self.hmw_repeatable_max_value = 0
      self.sli_min_value = 0
      self.sli_max_value = 0
      self.sli_delta_round_step = 0
      self.sli_delta_round_upwards = 0
      self.country_code = 0
      self.sli_unit_speed = 0
      self.tamper_alert_on_frames = 0
      self.tamper_alert_off_frames = 0
      self.tamper_alert_enable_j1939 = 0
      self.menu_ticks = [False] * 16
      self.advanced_menu_ticks = [False] * 16

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_43B().pack(_x.persistent_on_off, _x.volume_level, _x.hmw_level, _x.ldw_volume_level, _x.hmw_volume_level, _x.ldw_level, _x.pedestrian_warning_level, _x.sli_warning_level, _x.blinker_reminder_level, _x.virtual_bumper_level, _x.hw_repeatable_level, _x.buzzer_min_volume, _x.buzzer_max_volume, _x.buzzer_hmw_min_volume, _x.buzzer_hmw_max_volume, _x.buzzer_ldw_min_volume, _x.buzzer_ldw_max_volume, _x.ewiii_speed_indication, _x.disable_system_off, _x.calibration_source, _x.ldw_min_value, _x.ldw_max_value, _x.ldw_speed, _x.ped_min_value, _x.ped_max_value, _x.speed_for_high_low_beam_control, _x.virtual_bumper_min_value, _x.virtual_bumper_max_value, _x.blinker_reminder_min_value, _x.blinker_reminder_max_value, _x.hmw_min_value, _x.hmw_max_value, _x.hmw_repeatable_min_value, _x.hmw_repeatable_max_value, _x.sli_min_value, _x.sli_max_value, _x.sli_delta_round_step, _x.sli_delta_round_upwards, _x.country_code, _x.sli_unit_speed, _x.tamper_alert_on_frames, _x.tamper_alert_off_frames, _x.tamper_alert_enable_j1939))
      buff.write(_get_struct_16B().pack(*self.menu_ticks))
      buff.write(_get_struct_16B().pack(*self.advanced_menu_ticks))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 43
      (_x.persistent_on_off, _x.volume_level, _x.hmw_level, _x.ldw_volume_level, _x.hmw_volume_level, _x.ldw_level, _x.pedestrian_warning_level, _x.sli_warning_level, _x.blinker_reminder_level, _x.virtual_bumper_level, _x.hw_repeatable_level, _x.buzzer_min_volume, _x.buzzer_max_volume, _x.buzzer_hmw_min_volume, _x.buzzer_hmw_max_volume, _x.buzzer_ldw_min_volume, _x.buzzer_ldw_max_volume, _x.ewiii_speed_indication, _x.disable_system_off, _x.calibration_source, _x.ldw_min_value, _x.ldw_max_value, _x.ldw_speed, _x.ped_min_value, _x.ped_max_value, _x.speed_for_high_low_beam_control, _x.virtual_bumper_min_value, _x.virtual_bumper_max_value, _x.blinker_reminder_min_value, _x.blinker_reminder_max_value, _x.hmw_min_value, _x.hmw_max_value, _x.hmw_repeatable_min_value, _x.hmw_repeatable_max_value, _x.sli_min_value, _x.sli_max_value, _x.sli_delta_round_step, _x.sli_delta_round_upwards, _x.country_code, _x.sli_unit_speed, _x.tamper_alert_on_frames, _x.tamper_alert_off_frames, _x.tamper_alert_enable_j1939,) = _get_struct_43B().unpack(str[start:end])
      start = end
      end += 16
      self.menu_ticks = _get_struct_16B().unpack(str[start:end])
      self.menu_ticks = list(map(bool, self.menu_ticks))
      start = end
      end += 16
      self.advanced_menu_ticks = _get_struct_16B().unpack(str[start:end])
      self.advanced_menu_ticks = list(map(bool, self.advanced_menu_ticks))
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_43B().pack(_x.persistent_on_off, _x.volume_level, _x.hmw_level, _x.ldw_volume_level, _x.hmw_volume_level, _x.ldw_level, _x.pedestrian_warning_level, _x.sli_warning_level, _x.blinker_reminder_level, _x.virtual_bumper_level, _x.hw_repeatable_level, _x.buzzer_min_volume, _x.buzzer_max_volume, _x.buzzer_hmw_min_volume, _x.buzzer_hmw_max_volume, _x.buzzer_ldw_min_volume, _x.buzzer_ldw_max_volume, _x.ewiii_speed_indication, _x.disable_system_off, _x.calibration_source, _x.ldw_min_value, _x.ldw_max_value, _x.ldw_speed, _x.ped_min_value, _x.ped_max_value, _x.speed_for_high_low_beam_control, _x.virtual_bumper_min_value, _x.virtual_bumper_max_value, _x.blinker_reminder_min_value, _x.blinker_reminder_max_value, _x.hmw_min_value, _x.hmw_max_value, _x.hmw_repeatable_min_value, _x.hmw_repeatable_max_value, _x.sli_min_value, _x.sli_max_value, _x.sli_delta_round_step, _x.sli_delta_round_upwards, _x.country_code, _x.sli_unit_speed, _x.tamper_alert_on_frames, _x.tamper_alert_off_frames, _x.tamper_alert_enable_j1939))
      buff.write(self.menu_ticks.tostring())
      buff.write(self.advanced_menu_ticks.tostring())
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 43
      (_x.persistent_on_off, _x.volume_level, _x.hmw_level, _x.ldw_volume_level, _x.hmw_volume_level, _x.ldw_level, _x.pedestrian_warning_level, _x.sli_warning_level, _x.blinker_reminder_level, _x.virtual_bumper_level, _x.hw_repeatable_level, _x.buzzer_min_volume, _x.buzzer_max_volume, _x.buzzer_hmw_min_volume, _x.buzzer_hmw_max_volume, _x.buzzer_ldw_min_volume, _x.buzzer_ldw_max_volume, _x.ewiii_speed_indication, _x.disable_system_off, _x.calibration_source, _x.ldw_min_value, _x.ldw_max_value, _x.ldw_speed, _x.ped_min_value, _x.ped_max_value, _x.speed_for_high_low_beam_control, _x.virtual_bumper_min_value, _x.virtual_bumper_max_value, _x.blinker_reminder_min_value, _x.blinker_reminder_max_value, _x.hmw_min_value, _x.hmw_max_value, _x.hmw_repeatable_min_value, _x.hmw_repeatable_max_value, _x.sli_min_value, _x.sli_max_value, _x.sli_delta_round_step, _x.sli_delta_round_upwards, _x.country_code, _x.sli_unit_speed, _x.tamper_alert_on_frames, _x.tamper_alert_off_frames, _x.tamper_alert_enable_j1939,) = _get_struct_43B().unpack(str[start:end])
      start = end
      end += 16
      self.menu_ticks = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=16)
      self.menu_ticks = list(map(bool, self.menu_ticks))
      start = end
      end += 16
      self.advanced_menu_ticks = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=16)
      self.advanced_menu_ticks = list(map(bool, self.advanced_menu_ticks))
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_16B = None
def _get_struct_16B():
    global _struct_16B
    if _struct_16B is None:
        _struct_16B = struct.Struct("<16B")
    return _struct_16B
_struct_43B = None
def _get_struct_43B():
    global _struct_43B
    if _struct_43B is None:
        _struct_43B = struct.Struct("<43B")
    return _struct_43B
